//__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/
//! @file   敵のcpp
//!
//! @date   2017/02/07~
//!
//! @author sugiura	
//__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/

#include "Enemy.h"

//----------------------------------------------------------------------
//! @brief コンストラクタ
//!
//! @param[in] なし
//!
//! @return なし
//----------------------------------------------------------------------
Enemy::Enemy()
	  :ObjectBase()
{
	m_handle = new Texture(L"Resources\\Images\\Character\\Enemy\\enemy.png");
	m_grp_h = 32;
	m_grp_w = 32;
	m_pos_x = 640 / 2;
	m_pos_y = 352;
	m_spd_x = 0.1;
	m_rect = { m_grp_x, m_grp_y, m_grp_w, m_grp_h };
}

//----------------------------------------------------------------------
//! @brief デストラクタ
//!
//! @param[in] なし
//!
//! @return なし
//----------------------------------------------------------------------
Enemy::~Enemy()
{

}

//----------------------------------------------------------------------
//! @brief 更新処理
//!
//! @param[in] なし
//!
//! @return なし
//----------------------------------------------------------------------
void Enemy::Update()
{
	m_pos_x += m_spd_x;
	m_pos_y += m_spd_y;
}

//----------------------------------------------------------------------
//! @brief 描画処理
//!
//! @param[in] なし
//!
//! @return なし
//----------------------------------------------------------------------
void Enemy::Render()
{
	DrawObject(m_handle, m_pos_x, m_pos_y, m_rect);
}

//----------------------------------------------------------------------
//! @brief 移動
//!
//! @param[in] なし
//!
//! @return なし
//----------------------------------------------------------------------
void Enemy::move()
{

}

//----------------------------------------------------------------------
//! @brief ステージとの当たり判定
//!
//! @param[in] ステージ
//!
//! @return なし
//----------------------------------------------------------------------
bool Enemy::collisionStage(StageBase* stage)
{
	if (stage->getPosX()					<= m_pos_x + m_grp_w &&	//右側
		stage->getPosX() + stage->getGrpW() >= m_pos_x			 &&	//左側
		stage->getPosY()					<= m_pos_y + m_grp_h &&	//下側
		stage->getPosY() + stage->getGrpH() >= m_pos_y)				//上側
	{
		return true;
	}
	return false;
}




